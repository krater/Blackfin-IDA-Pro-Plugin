/*
   IDA Pro Processor Module for Blackfin Instruction Set
   
   Copyright (C) 2011 
   Andreas Schuler <andreas@schulerdev.de>

   Based on parts of libopcodes (Free Software Foundation, Inc.) and
   Simple Python Byte Code Module (Chris Eagle <cseagle@gmail.com>)
   
   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the Free
   Software Foundation; either version 2 of the License, or (at your option) 
   any later version.
   
   This program is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
   FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
   more details.
   
   You should have received a copy of the GNU General Public License along with 
   this program; if not, write to the Free Software Foundation, Inc., 59 Temple 
   Place, Suite 330, Boston, MA 02111-1307 USA
*/

#include <ida.hpp>
#include <frame.hpp>
#include "blackfin.h"
#include "dis-asm.h"

disassemble_info edi;

//----------------------------------------------------------------------
int idaapi blackfin_emu(void) 
{
	//Get Information from disassembler
	disasm_insn_bfin(cmd.ea,&edi);

	//Add autogenerated comments
	if(strlen(edi.comment))
		set_cmt(cmd.ea,edi.comment,true);

	//Add jump/call code references
	if(edi.feature&CF_JUMP) 
	{
		ua_add_cref(0,edi.caddr,edi.ctype);
	}

	//Add data references
	if(edi.drefmode==DMODE_LOAD_HIGH)
	{
		ua_add_dref(0,edi.daddr,edi.dtype);
	}

	//Add the sequential flow as long as CF_STOP is not set
	if(!(edi.feature&CF_STOP)) 
	{
		//cmd.ea + cmd.size computes the address of the next instruction
		ua_add_cref(0, cmd.ea + cmd.size, fl_F);
	} 

	return cmd.size;
}

/*
static void setup_far_func(func_t *pfn)
{
  if ( (pfn->flags & FUNC_FAR) == 0 )
  {
    ea_t ea1 = pfn->startEA;
    ea_t ea2 = pfn->endEA;
    while ( ea1 < ea2 )
    {
      if ( isCode(get_flags_novalue(ea1)) )
      {
        ua_ana0(ea1);
        /*if ( is_far_ending() )
        {
          pfn->flags |= FUNC_FAR;
          update_func(pfn);
          break;
        }
      }
      ea1 = next_head(ea1, ea2);
    }
  }
}
*/

bool create_func_frame(func_t *pfn)
{
  if ( pfn != NULL )
  {
//    setup_far_func(pfn);
//    uval_t argsize = find_ret_purged(pfn);
    add_frame(pfn, 0, 0, 0/*argsize*/);
  }
  return true;
}



